{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/2018-07-02/better-bash-history/","result":{"data":{"site":{"siteMetadata":{"title":"Thomas Laurenson"}},"markdownRemark":{"id":"55f8da95-2948-5eac-8c5a-35c8cadbe300","excerpt":"Contents Introduction How to Save All BASH History Additional BASH History Configuration BASH Configuration Overview A BASH Script to Configure Enhanced BASH…","html":"<h2 id=\"contents\" style=\"position:relative;\"><a href=\"#contents\" aria-label=\"contents permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Contents</h2>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#introduction\">Introduction</a></li>\n<li><a href=\"#how-to-save-all-bash-history\">How to Save All BASH History</a></li>\n<li><a href=\"#additional-bash-history-configuration\">Additional BASH History Configuration</a></li>\n<li><a href=\"#bash-configuration-overview\">BASH Configuration Overview</a></li>\n<li><a href=\"#a-bash-script-to-configure-enhanced-bash-history\">A BASH Script to Configure Enhanced BASH History</a></li>\n</ul>\n</div>\n<h2 id=\"introduction\" style=\"position:relative;\"><a href=\"#introduction\" aria-label=\"introduction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction</h2>\n<p>It is my continual venture to make my job easier. Like my sysadmin roots taught me, try to automate the process, and document thoroughly. In my job as a lecturer, I try to automate many aspects of the courses I run. Even though it takes time up front… next semester will be easier!</p>\n<p>I learned a lesson about using VMs for tertiary assessments early on. The more information about what has been performed on a system, the easier (and sometimes faster) it is to assess the tasks performed. For example, in the Linux and Security paper, I teach it is very useful to see the complete BASH command history. After my first semester of teaching, I noticed the bash history was somewhat limited in a collection of assignment VMs. It turned out that most of the history was not being retained, due to students having multiple sessions (SSH, TTYs etc.). This needed to be solved. If there is a rich history, it will be better for me (marking) and better for them (reviewing their own command history). The goals:</p>\n<ul>\n<li>Implement a solution to preserve BASH history in multiple sessions</li>\n<li>Add a timestamp to each command stored</li>\n</ul>\n<p>The first problem was determining why BASH was not maintaining a complete history. A quick Google and some research discovered. Apparently, each open terminal (SSH session etc.) has an independent history file buffer. This file is known as the <code class=\"language-text\">.bash_history</code> file, a hidden file in the home directory of each user. It has the environment variable of <code class=\"language-text\">$HISTFILE</code>. For example: </p>\n<div class=\"gatsby-highlight\" data-language=\"none\"><pre class=\"language-none\"><code class=\"language-none\">thomasl@server:~$ echo $HISTFILE\n/home/thomasl/.bash_history</code></pre></div>\n<p>Back to the problem: previously entered commands are stored in <code class=\"language-text\">$HISTFILE</code> when the terminal is closed. If you wanted to search for a specific command, for example, <code class=\"language-text\">iptables</code>, you would run the following command:</p>\n<div class=\"gatsby-highlight\" data-language=\"none\"><pre class=\"language-none\"><code class=\"language-none\">history | grep iptables</code></pre></div>\n<p>However, if any <code class=\"language-text\">iptables</code> command was run in a different shell or session, it is not visible in the current session. To see the full command history you would need to close all shells, open a new shell and run the history command again! In addition, if a shell is not exited cleanly, no history will be saved. According to the <a href=\"https://www.gnu.org/software/bash/manual/html_node/Bash-History-Facilities.html\">Bash History Facilities</a> man page from GNU, the history is not saved if the terminal is not exited cleanly. An example of this is closing a PuTTY session by using <code class=\"language-text\">Ctrl + F4</code> or closing the window using the <code class=\"language-text\">X</code> button, instead of typing <code class=\"language-text\">exit</code> in the shell itself. Unfortunately, I see students doing this regularly. I shouldn’t kid myself, even I do this occasionally!</p>\n<h2 id=\"how-to-save-all-bash-history\" style=\"position:relative;\"><a href=\"#how-to-save-all-bash-history\" aria-label=\"how to save all bash history permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How to Save All BASH History</h2>\n<p>This section discusses each command found to be useful to preserve all BASH commands in the history file. The full script for enhancing BASH history is provided at the end of the article.</p>\n<p>To prevent loss of command history, it is possible to append to the history file instead of overwriting previous content from each session. This is configurable using the <code class=\"language-text\">histappend</code> shell option, as illustrated below. Please note that the <code class=\"language-text\">shopt</code> command is a shell builtin to set and unset (enable and disable) various Bash shell options:</p>\n<div class=\"gatsby-highlight\" data-language=\"none\"><pre class=\"language-none\"><code class=\"language-none\"># Configure BASH to append (rather than overwrite the history):\nshopt -s histappend</code></pre></div>\n<p>The next configuration specifies that there is an attempt to save each line of a multi-line command in the same history entry. This would add semicolons where necessary to preserve the syntactic correctness of the original command. </p>\n<div class=\"gatsby-highlight\" data-language=\"none\"><pre class=\"language-none\"><code class=\"language-none\"># Attempt to save all lines of a multiple-line command in the same entry\nshopt -s cmdhist</code></pre></div>\n<p>The final major setting is to configure the history file to reload after every entry. This means that we can append after every executed command, rather than when a shell session is exited. To achieve this, the <code class=\"language-text\">PROMPT_COMMAND</code> setting can be leveraged. Any value specified for the <code class=\"language-text\">PROMPT_COMMAND</code> is executed as a command prior to issuing each primary prompt. We will leverage it to reload the BASH history.</p>\n<div class=\"gatsby-highlight\" data-language=\"none\"><pre class=\"language-none\"><code class=\"language-none\"># After each command, append to the history file and reread it\nexport PROMPT_COMMAND=\"${PROMPT_COMMAND:+$PROMPT_COMMAND$\"\\n\"}history -a; history -c; history -r\"</code></pre></div>\n<p>A brief summary of the <code class=\"language-text\">history</code> commands:</p>\n<ul>\n<li><code class=\"language-text\">history -a</code>: Append to the history file</li>\n<li><code class=\"language-text\">history -c</code>: Clear the history (of the current shell)</li>\n<li><code class=\"language-text\">history -r</code>: Read the history file and append its contents to the history list</li>\n</ul>\n<p>As you can see, these series of command basically append, clear and reload the contents of the <code class=\"language-text\">.bash_history</code> file. It is essential to clear the file as if this was not performed… there would be duplicate history entries when the shell session was exited!</p>\n<p>The three specified commands and configuration (<code class=\"language-text\">histappend</code>, <code class=\"language-text\">cmdhist</code>, and <code class=\"language-text\">PROMPT_COMMAND</code>) provide the functionality to save all BASH history as soon as it is entered. Excellent!</p>\n<h2 id=\"additional-bash-history-configuration\" style=\"position:relative;\"><a href=\"#additional-bash-history-configuration\" aria-label=\"additional bash history configuration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Additional BASH History Configuration</h2>\n<p>The previous discussion specified a robust configuration for saving all BASH command history. However, there are some additional configurations that are also useful.</p>\n<p>The <code class=\"language-text\">HISTTIMEFORMAT</code> variable allows the inclusion of a timestamp on each command entry in the history file. It uses the same format string method as the <a href=\"https://linux.die.net/man/3/strftime\">strftime</a> command. I prefer the following configuration:</p>\n<div class=\"gatsby-highlight\" data-language=\"none\"><pre class=\"language-none\"><code class=\"language-none\"># Print the timestamp of each command\nHISTTIMEFORMAT='%F %T '</code></pre></div>\n<p>Which results in the following timestamp: <code class=\"language-text\">%Y-%m-%d %H:%M:%S</code></p>\n<p>For example: <code class=\"language-text\">2018-05-17 19:24:05</code></p>\n<p>However, you could use any type of configuration you like. The <a href=\"https://linux.die.net/man/3/strftime\">strftime man page</a> has a complete summary of how to use the command.</p>\n<p>Another very important setting is the <code class=\"language-text\">HISTFILESIZE</code> configuration. This variable specifies the <strong>maximum number of lines</strong>, which has a default value of <code class=\"language-text\">500</code>. This can be set to <code class=\"language-text\">-1</code> to remove the line count limit.</p>\n<div class=\"gatsby-highlight\" data-language=\"none\"><pre class=\"language-none\"><code class=\"language-none\"># Set no limit for history file size\nHISTFILESIZE=-1</code></pre></div>\n<p>Interestingly, there is another variable named <code class=\"language-text\">HISTSIZE</code> which has the exact same description as <code class=\"language-text\">HISTFILESIZE</code>. I have not tested it, but it seems prudent to also set this variable to a value of <code class=\"language-text\">-1</code> to remove any line count limit.</p>\n<div class=\"gatsby-highlight\" data-language=\"none\"><pre class=\"language-none\"><code class=\"language-none\"># Set no limit for history file size\nHISTSIZE=-1</code></pre></div>\n<p>The <code class=\"language-text\">HISTCONTROL</code> variable is used to control how commands are saved on the history list. Of the available configurations, the value of <code class=\"language-text\">ignoredups</code> causes lines matching the previous history entry to not be saved. Basically, do not save duplicates of the same command run twice (or more times) in succession.</p>\n<div class=\"gatsby-highlight\" data-language=\"none\"><pre class=\"language-none\"><code class=\"language-none\"># Do not store a duplicate of the last entered command\nHISTCONTROL=ignoredups</code></pre></div>\n<h2 id=\"bash-configuration-overview\" style=\"position:relative;\"><a href=\"#bash-configuration-overview\" aria-label=\"bash configuration overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BASH Configuration Overview</h2>\n<p>There are three configuration methods to enhance BASH history:</p>\n<ul>\n<li>Execute the commands at the prompt of the logged in user</li>\n<li>Enter the commands in a user’s <code class=\"language-text\">.bashrc</code> file</li>\n<li>Enter the commands in the system-wide <code class=\"language-text\">.bashrc</code> file</li>\n</ul>\n<p>The first option is to execute the specified commands can be executed directly in a shell. However, this approach will only set the configuration until the BASH session is exited. So, if you exit an SSH session, or log out, the configuration would be lost. </p>\n<p>The second option is to enter the commands into the <code class=\"language-text\">.bashrc</code> file of a specific user. This file present in the home directory of each user on the Linux system. For example, when logged in as <code class=\"language-text\">nickfury</code>, the file will be located at <code class=\"language-text\">~/.bashrc</code> or usually <code class=\"language-text\">/home/nickfury/.bashrc</code>, depending on the type of Linux OS installed.</p>\n<p>The third option is to enter the commands into the <code class=\"language-text\">/etc/bash.bashrc</code> file. This is the system-wide file for BASH configuration. This file is a shell script that BASH runs whenever it is started interactively. Therefore, it is run every time a BASH session is created, or whenever an SSH or TTY BASH session is started. </p>\n<h2 id=\"a-bash-script-to-configure-enhanced-bash-history\" style=\"position:relative;\"><a href=\"#a-bash-script-to-configure-enhanced-bash-history\" aria-label=\"a bash script to configure enhanced bash history permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>A BASH Script to Configure Enhanced BASH History</h2>\n<p>The full script I use for configuring BASH history is provided below for reference. This script applies all the configuration discussed above into the system-wide <code class=\"language-text\">/etc/bash.bashrc</code> file, so that the configuration is enabled for all users.</p>\n<p>I have performed testing on this configuration on an Ubuntu Linux 16.04.4 server system. I performed a variety of tests including accessing the VM from Virtual Machine Remote Console (VMRC), the normal Remote Console in a web browser, and through SSH using PuTTY and SSH client on an Ubuntu Desktop system. Everything ran smoothly, and I could see the history command, and <code class=\"language-text\">.bash_history</code> file updating for a variety of users. </p>\n<div class=\"gatsby-highlight\" data-language=\"none\"><pre class=\"language-none\"><code class=\"language-none\">echo \">>> Starting\"\necho \">>> Loading configuration into /etc/bash.bashrc\"\n\necho \"HISTTIMEFORMAT='%F %T '\" >> /etc/bash.bashrc\necho 'HISTFILESIZE=-1' >> /etc/bash.bashrc\necho 'HISTSIZE=-1' >> /etc/bash.bashrc\necho 'HISTCONTROL=ignoredups' >> /etc/bash.bashrc\n\n# Custom history configuration\necho '# Configure BASH to append (rather than overwrite the history):' >> /etc/bash.bashrc\necho 'shopt -s histappend' >> /etc/bash.bashrc\n\necho '# Attempt to save all lines of a multiple-line command in the same entry' >> /etc/bash.bashrc\necho 'shopt -s cmdhist' >> /etc/bash.bashrc\n\necho '# After each command, append to the history file and reread it' >> /etc/bash.bashrc\necho 'export PROMPT_COMMAND=\"${PROMPT_COMMAND:+$PROMPT_COMMAND$\"\\n\"}history -a; history -c; history -r\"' >> /etc/bash.bashrc\n\n# Reload BASH for settings to take effect\necho \">>> Reloading BASH\"\nexec \"$BASH\"\n\necho \">>> Finished. Exiting.\"</code></pre></div>\n<p>I have made a GitHub gist with the resultant script called <a href=\"https://gist.github.com/thomaslaurenson/ae72d4b4ec683f5a1850d42338a9a4ab\">better_history.sh</a>. This can be downloaded and run as the root user. An example of how to execute the script is provided below (for an Ubuntu system):</p>\n<div class=\"gatsby-highlight\" data-language=\"none\"><pre class=\"language-none\"><code class=\"language-none\">sudo su\nchmod u+x better_history.sh # permission to execute, if required\n./better_history.sh\nexit</code></pre></div>\n<p>Finally, below is a small snippet of the expected output from the improved BASH history configuration.</p>\n<div class=\"gatsby-highlight\" data-language=\"none\"><pre class=\"language-none\"><code class=\"language-none\">    1  2018-05-17 19:24:05 vim .bash_history\n    2  2018-05-17 19:25:26 clear\n    3  2018-05-17 19:25:50 vim validate_numbers.cpp\n    4  2018-05-17 19:26:05 g++ validate_numbers.cpp -o validate_numbers\n    5  2018-05-17 19:26:10 chmod u+x validate_numbers\n    6  2018-05-17 19:26:12 ./validate_numbers\n    7  2018-05-17 19:51:31 sudo poweroff</code></pre></div>\n<p>Establishing a better BASH history configuration has made my life a lot easier. The script provided in this article is executed on every Linux system I use at work and in personal life to improve general well-being!</p>","frontmatter":{"title":"Better Bash History","date":"July 02, 2018","tags":["Linux","Bash","History"],"description":"Improved BASH history for multiple sessions, unclean shell exits and timestamps for every command executed.","thumbnail":"bash.png"}},"previous":{"fields":{"slug":"/blog/2018-06-30/building-a-new-Jekyll-powered-blog-for-GitHub-pages/"},"frontmatter":{"title":"Building a Jekyll-powered blog for GitHub pages"}},"next":{"fields":{"slug":"/blog/2018-07-03/metasploitable3-building-the-ubuntu-linux-version/"},"frontmatter":{"title":"Metasploitable3 - Building the Ubuntu Linux Version"}}},"pageContext":{"id":"55f8da95-2948-5eac-8c5a-35c8cadbe300","previousPostId":"35b4b5fd-4388-5996-9474-76f1055b8979","nextPostId":"b307e159-e6ad-5ec3-a739-3bb5138e9fb4"}},"staticQueryHashes":["1771194231","2841359383","3880320062"]}